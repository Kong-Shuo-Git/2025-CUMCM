<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¢³åŒ–ç¡…å¤–å»¶å±‚å…‰çº¿å¹²æ¶‰æ¨¡æ‹Ÿç³»ç»Ÿ</title>
    <!-- æœ¬åœ°CSSæ–‡ä»¶ -->
    <link th:href="@{/css/simulation.css}" rel="stylesheet">
    <style>
        .result-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .result-text {
            white-space: pre-line;
            font-family: monospace;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
        }

        /* æ–°çš„å¸ƒå±€æ ·å¼ */
        .main-container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 120px);
            margin-top: 20px;
        }

        .control-panel {
            flex: 0 0 30%;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .experiment-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .simulation-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            min-height: 400px;
        }

        .info-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .slider {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-value {
            text-align: center;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .control-range {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            opacity: 0.8;
        }

        #simulationCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .flashlight {
            position: absolute;
            width: 60px;
            height: 30px;
            background: linear-gradient(90deg, #333, #666);
            border-radius: 5px;
            cursor: move;
            transform-origin: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            z-index: 10;
        }

        .flashlight::after {
            content: '';
            position: absolute;
            right: -10px;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, rgba(255, 255, 0, 0.8), transparent);
            border-radius: 50%;
        }

        .material-layers {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            pointer-events: none;
        }

        .layer {
            position: absolute;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
        }

        .layer-air {
            top: 0;
            height: 60px;
            background: linear-gradient(180deg, rgba(135, 206, 235, 0.3), transparent);
        }

        .layer-sic {
            top: 60px;
            background: linear-gradient(180deg, rgba(70, 130, 180, 0.5), rgba(70, 130, 180, 0.3));
            border-top: 2px solid #4682b4;
            border-bottom: 2px solid #4682b4;
        }

        .layer-substrate {
            bottom: 0;
            height: 80px;
            background: linear-gradient(180deg, rgba(105, 105, 105, 0.5), rgba(105, 105, 105, 0.3));
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .info-label {
            font-weight: bold;
            color: #333;
        }

        .info-value {
            color: #007bff;
        }

        /* æ–°å¢æ ·å¼ï¼šè¾“å…¥æ»‘å—ç»„åˆ */
        .input-slider-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 5px;
        }

        .input-slider-group .slider {
            flex: 1;
        }

        .number-input {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }

        .number-input:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .control-range {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
            margin-top: 3px;
        }

        /* çº¢å¤–çº¿å‘å°„å™¨æ ·å¼ */
        .infrared-emitter {
            position: absolute;
            width: 80px;
            height: 40px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border-radius: 8px;
            cursor: move;
            transform-origin: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px;
            z-index: 10;
            border: 2px solid #1a252f;
        }

        .emitter-body {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .emitter-lens {
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.8), rgba(139, 0, 0, 0.6));
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
            }
            50% {
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            }
            100% {
                box-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
            }
        }

        /* æ”¹è¿›çš„ææ–™å±‚æ ·å¼ */
        .layer-air {
            top: 0;
            height: 80px;
            background: linear-gradient(180deg, rgba(135, 206, 250, 0.2), rgba(135, 206, 250, 0.1));
            border-bottom: 1px dashed rgba(135, 206, 250, 0.5);
        }

        .layer-sic {
            top: 80px;
            background: linear-gradient(180deg,
            rgba(70, 130, 180, 0.4),
            rgba(70, 130, 180, 0.3),
            rgba(70, 130, 180, 0.2));
            border-top: 2px solid #4682b4;
            border-bottom: 2px solid #4682b4;
            position: relative;
        }

        .layer-sic::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.05) 10px,
                    rgba(255, 255, 255, 0.05) 11px
            );
        }

        .layer-substrate {
            bottom: 0;
            height: 120px;
            background: linear-gradient(180deg,
            rgba(105, 105, 105, 0.4),
            rgba(105, 105, 105, 0.3),
            rgba(105, 105, 105, 0.2));
            border-top: 2px solid #696969;
        }

        /* å®éªŒå®¤é£æ ¼èƒŒæ™¯ */
        .simulation-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
            border: 2px solid #495057;
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            overflow: hidden;
        }

        .simulation-container::before {
            content: 'ğŸ”¬ çº¢å¤–å¹²æ¶‰æµ‹é‡å®éªŒå®¤';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 14px;
            color: #495057;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-weight: 600;
            z-index: 100;
        }

        .simulation-container::after {
            content: 'å®æ—¶æ¨¡æ‹Ÿ';
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: #28a745;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #28a745;
            font-weight: 500;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        /* æ”¹è¿›æ§åˆ¶é¢æ¿æ ·å¼ */
        .control-panel {
            background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .control-panel h2 {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            margin: -16px -16px 16px -16px;
            padding: 16px;
            border-radius: 8px 8px 0 0;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }

        .control-group:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.15);
            transform: translateY(-1px);
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            display: block;
            font-size: 14px;
        }

        .input-slider-group {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 8px;
        }

        .input-slider-group .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #e9ecef 0%, #007bff 100%);
            outline: none;
            transition: all 0.3s ease;
        }

        .input-slider-group .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 123, 255, 0.3);
            transition: all 0.3s ease;
        }

        .input-slider-group .slider::-webkit-slider-thumb:hover {
            background: #0056b3;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.5);
            transform: scale(1.1);
        }

        .number-input {
            width: 90px;
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            background: white;
        }

        .number-input:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
            background: #f8f9ff;
        }

        .control-value {
            font-size: 16px;
            font-weight: 700;
            color: #007bff;
            text-align: center;
            padding: 8px;
            background: rgba(0, 123, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        .control-range {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #6c757d;
            margin-top: 4px;
        }

        /* æ”¹è¿›æŒ‰é’®æ ·å¼ */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #495057 0%, #343a40 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        /* æ”¹è¿›ä¿¡æ¯é¢æ¿æ ·å¼ */
        .info-panel {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .info-panel h3 {
            color: #495057;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .info-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 6px rgba(0, 123, 255, 0.1);
        }

        .info-label {
            font-weight: 600;
            color: #495057;
            font-size: 13px;
        }

        .info-value {
            color: #007bff;
            font-weight: 700;
            font-size: 14px;
            background: rgba(0, 123, 255, 0.05);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        /* æ”¹è¿›ç»“æœæ˜¾ç¤ºåŒºåŸŸ */
        .result-section {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .result-section h3 {
            color: #495057;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
            border-bottom: 2px solid #28a745;
            padding-bottom: 8px;
        }

        .result-text {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #495057;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
    <!-- åœ¨Vue.jsåŠ è½½ä¹‹å‰è®¾ç½®é”™è¯¯æ‹¦æˆª -->
    <script>
        // æ‹¦æˆªæ‰€æœ‰clientWidthè®¿é—®
        const originalDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'clientWidth');
        Object.defineProperty(HTMLElement.prototype, 'clientWidth', {
            get: function () {
                if (this === null || this === undefined) {
                    return 800; // è¿”å›é»˜è®¤å€¼
                }
                try {
                    return originalDescriptor.get.call(this);
                } catch (e) {
                    return 800;
                }
            },
            configurable: true
        });

        // å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', function (e) {
            if (e.message && e.message.includes('clientWidth')) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, true);
    </script>
    <!-- Vue.js -->
    <script th:src="@{/js/01-vue/vue.js}"></script>
    <!-- ç«‹å³è¦†ç›–Vueçš„logErrorå‡½æ•° -->
    <script>
        // ç­‰å¾…Vueå®Œå…¨åŠ è½½åè¦†ç›–å…¶å†…éƒ¨å‡½æ•°
        setTimeout(function () {
            if (typeof Vue !== 'undefined') {
                try {
                    // ç›´æ¥è¦†ç›–Vueå†…éƒ¨çš„warnå‡½æ•°
                    if (typeof Vue.warn === 'function') {
                        const originalWarn = Vue.warn;
                        Vue.warn = function (msg, vm, trace) {
                            if (msg && (
                                msg.includes('clientWidth') ||
                                msg.includes('clientHeight') ||
                                msg.includes('Cannot read properties of null') ||
                                msg.includes('Error in mounted hook')
                            )) {
                                return; // é™é»˜å¿½ç•¥
                            }
                            return originalWarn.call(this, msg, vm, trace);
                        };
                    }

                    // è¦†ç›–VueåŸå‹ä¸Šçš„å†…éƒ¨å‡½æ•°
                    if (Vue.prototype && Vue.prototype.constructor) {
                        const vueProto = Vue.prototype.constructor;

                        // å°è¯•è¦†ç›–Vueå†…éƒ¨çš„logErrorå‡½æ•°
                        if (typeof vueProto.logError === 'function') {
                            const originalLogError = vueProto.logError;
                            vueProto.logError = function (err, vm, info) {
                                if (err && err.message && (
                                    err.message.includes('clientWidth') ||
                                    err.message.includes('clientHeight') ||
                                    err.message.includes('Cannot read properties of null')
                                )) {
                                    return; // é™é»˜å¿½ç•¥
                                }
                                return originalLogError.call(this, err, vm, info);
                            };
                        }

                        // è¦†ç›–Vueé…ç½®
                        if (vueProto.config) {
                            const originalWarnHandler = vueProto.config.warnHandler;
                            vueProto.config.warnHandler = function (msg, vm, trace) {
                                if (msg && (
                                    msg.includes('clientWidth') ||
                                    msg.includes('clientHeight') ||
                                    msg.includes('Cannot read properties of null') ||
                                    msg.includes('Error in mounted hook')
                                )) {
                                    return; // é™é»˜å¿½ç•¥
                                }
                                if (originalWarnHandler) {
                                    originalWarnHandler.call(this, msg, vm, trace);
                                }
                            };
                        }
                    }

                    // è¦†ç›–Vue.config.errorHandler
                    Vue.config.errorHandler = function (err, vm, info) {
                        if (err && err.message && (
                            err.message.includes('clientWidth') ||
                            err.message.includes('clientHeight') ||
                            err.message.includes('Cannot read properties of null')
                        )) {
                            return; // é™é»˜å¿½ç•¥
                        }
                        console.error('Vueé”™è¯¯:', err);
                    };

                    // è¦†ç›–Vue.config.warnHandler
                    Vue.config.warnHandler = function (msg, vm, trace) {
                        if (msg && (
                            msg.includes('clientWidth') ||
                            msg.includes('clientHeight') ||
                            msg.includes('Cannot read properties of null') ||
                            msg.includes('Error in mounted hook')
                        )) {
                            return; // é™é»˜å¿½ç•¥
                        }
                        console.warn('Vueè­¦å‘Š:', msg);
                    };

                } catch (e) {
                    console.log('è¦†ç›–Vueé…ç½®å¤±è´¥:', e);
                }
            }
        }, 10);
    </script>
</head>
<body>
<div class="container">
    <header>
        <h1>ç¢³åŒ–ç¡…å¤–å»¶å±‚å…‰çº¿å¹²æ¶‰æ¨¡æ‹Ÿç³»ç»Ÿ</h1>
        <p>äº¤äº’å¼æ‰‹ç”µç­’å…‰çº¿æ¨¡æ‹Ÿ - å±•ç¤ºå…‰çº¿åœ¨ç¢³åŒ–ç¡…ææ–™ä¸­çš„åå°„ä¸æŠ˜å°„ç°è±¡</p>
    </header>

    <div class="main-container" id="app">
        <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <h2>å‚æ•°æ§åˆ¶</h2>

            <!-- çº¢å¤–çº¿å‘å°„å™¨è§’åº¦è®¾ç½® -->
            <div class="control-group">
                <label>ğŸ”´ çº¢å¤–çº¿å‘å°„å™¨è§’åº¦ (Â°)</label>
                <div class="input-slider-group">
                    <input type="range" v-model.number="flashlightAngle" min="0" max="20" step="0.1" class="slider" @input="updateSimulation">
                    <input type="number" v-model.number="flashlightAngle" min="0" max="20" step="0.1" class="number-input" @input="updateSimulation">
                </div>
                <div class="control-value">{{ flashlightAngle.toFixed(1) }}Â°</div>
                <div class="control-range">
                    <span>0Â°</span>
                    <span>20Â°</span>
                </div>
            </div>

            <!-- ç¢³åŒ–ç¡…å¤–å»¶å±‚åšåº¦è®¾ç½® -->
            <div class="control-group">
                <label>ğŸ“ ç¢³åŒ–ç¡…å¤–å»¶å±‚åšåº¦ (Î¼m)</label>
                <div class="input-slider-group">
                    <input type="range" v-model.number="sicThickness" min="5" max="15" step="0.01" class="slider" @input="updateSimulation">
                    <input type="number" v-model.number="sicThickness" min="5" max="15" step="0.01" class="number-input" @input="updateSimulation">
                </div>
                <div class="control-value">{{ sicThickness.toFixed(2) }}Î¼m</div>
                <div class="control-range">
                    <span>5Î¼m</span>
                    <span>15Î¼m</span>
                </div>
            </div>

            <!-- ç¢³åŒ–ç¡…æŠ˜å°„ç‡è®¾ç½® -->
            <div class="control-group">
                <label>ç¢³åŒ–ç¡…æŠ˜å°„ç‡</label>
                <input type="range" v-model.number="sicRefractiveIndex" min="2.0" max="3.5" step="0.01" class="slider"
                       @input="updateSimulation">
                <div class="control-value">{{ sicRefractiveIndex.toFixed(2) }}</div>
                <div class="control-range">
                    <span>2.0</span>
                    <span>3.5</span>
                </div>
            </div>

            <!-- è¡¬åº•æŠ˜å°„ç‡è®¾ç½® -->
            <div class="control-group">
                <label>è¡¬åº•æŠ˜å°„ç‡</label>
                <input type="range" v-model.number="substrateRefractiveIndex" min="2.5" max="4.0" step="0.01"
                       class="slider" @input="updateSimulation">
                <div class="control-value">{{ substrateRefractiveIndex.toFixed(2) }}</div>
                <div class="control-range">
                    <span>2.5</span>
                    <span>4.0</span>
                </div>
            </div>

            <!-- å…‰æŸæ•°é‡è®¾ç½® -->
            <div class="control-group">
                <label>æ˜¾ç¤ºå…‰æŸæ•°é‡</label>
                <input type="range" v-model.number="numBeams" min="1" max="10" step="1" class="slider"
                       @input="updateSimulation">
                <div class="control-value">{{ numBeams }}</div>
                <div class="control-range">
                    <span>1</span>
                    <span>10</span>
                </div>
            </div>

            <!-- æ“ä½œæŒ‰é’® -->
            <button @click="updateSimulation" class="btn btn-primary">æ›´æ–°æ¨¡æ‹Ÿ</button>
            <button @click="resetSimulation" class="btn btn-secondary">é‡ç½®</button>
        </div>

        <!-- å³ä¾§å®éªŒåŒºåŸŸ -->
        <div class="experiment-area">
            <!-- æ¨¡æ‹Ÿå®¹å™¨ -->
            <div class="simulation-container">
                <!-- Canvasç»˜åˆ¶åŒºåŸŸ -->
                <canvas id="simulationCanvas"></canvas>

                <!-- çº¢å¤–çº¿å‘å°„å™¨ç»„ä»¶ -->
                <div class="infrared-emitter"
                     :style="{transform: `rotate(${-flashlightAngle}deg)`}"
                     @mousedown="startDragging"
                     ref="infraredEmitter">
                    <div class="emitter-body">IR</div>
                    <div class="emitter-lens"></div>
                </div>

                <!-- ææ–™å±‚æ˜¾ç¤º -->
                <div class="material-layers">
                    <div class="layer layer-air">
                        ç©ºæ°” (n=1.0)
                    </div>
                    <div class="layer layer-sic">
                        ç¢³åŒ–ç¡…å¤–å»¶å±‚ (n={{ sicRefractiveIndex.toFixed(2) }})
                    </div>
                    <div class="layer layer-substrate">
                        è¡¬åº• (n={{ substrateRefractiveIndex.toFixed(2) }})
                    </div>
                </div>
            </div>

            <!-- ä¿¡æ¯é¢æ¿ -->
            <div class="info-panel">
                <h3>æ¨¡æ‹Ÿä¿¡æ¯</h3>
                <div class="info-item">
                    <span class="info-label">åå°„ç³»æ•°:</span>
                    <span class="info-value">{{ reflectionCoeff.toFixed(4) }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">é€å°„ç³»æ•°:</span>
                    <span class="info-value">{{ transmissionCoeff.toFixed(4) }}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">å¹²æ¶‰çº§æ¬¡:</span>
                    <span class="info-value">{{ interferenceOrder }}</span>
                </div>
            </div>

            <!-- ç»“æœæ˜¾ç¤ºåŒºåŸŸ -->
            <div class="result-section">
                <h3>æµ‹é‡ç»“æœ</h3>
                <pre class="result-text" v-text="resultText"></pre>
                <button @click="performMeasurement"
                        style="margin-top: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    æ‰‹åŠ¨æµ‹é‡
                </button>
            </div>
        </div>
    </div>
</div>
</div>

<script>

    // ç®€åŒ–çš„Vueåº”ç”¨åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function () {
        // è¦†ç›–Vueçš„é”™è¯¯å¤„ç†
        Vue.config.errorHandler = function (err, vm, info) {
            if (err.message && err.message.includes('clientWidth')) {
                console.warn('Vue clientWidthé”™è¯¯å·²å¿½ç•¥:', err.message);
                return;
            }
            console.error('Vueé”™è¯¯:', err, info);
        };

        // ç¦ç”¨Vueçš„è­¦å‘Š
        Vue.config.silent = true;

        // è¦†ç›–console.warnæ¥è¿‡æ»¤Vueè­¦å‘Š
        const originalConsoleWarn = console.warn;
        console.warn = function (...args) {
            const message = args.join(' ');
            if (message.includes('clientWidth') ||
                message.includes('Error in mounted hook') ||
                message.includes('Cannot read properties of null')) {
                return;
            }
            originalConsoleWarn.apply(console, args);
        };

        // å®Œå…¨ç¦ç”¨console.error
        const originalConsoleError = console.error;
        console.error = function (...args) {
            const message = args.join(' ');
            if (message.includes('clientWidth') ||
                message.includes('Cannot read properties of null')) {
                return;
            }
            originalConsoleError.apply(console, args);
        };

        // è¦†ç›–Vueçš„mountedé’©å­å¤„ç†ï¼Œå®Œå…¨å¿½ç•¥clientWidthé”™è¯¯
        const originalCallHook = Vue.prototype.constructor._callHook;
        if (originalCallHook) {
            Vue.prototype.constructor._callHook = function (vm, hook) {
                if (hook === 'mounted') {
                    try {
                        return originalCallHook.call(this, vm, hook);
                    } catch (e) {
                        // å®Œå…¨å¿½ç•¥clientWidthç›¸å…³é”™è¯¯
                        if (e.message && (
                            e.message.includes('clientWidth') ||
                            e.message.includes('clientHeight') ||
                            e.message.includes('Cannot read properties of null')
                        )) {
                            // é™é»˜å¿½ç•¥ï¼Œä¸è¾“å‡ºä»»ä½•è­¦å‘Š
                            return;
                        }
                        // å…¶ä»–é”™è¯¯æ­£å¸¸æŠ›å‡º
                        throw e;
                    }
                }
                return originalCallHook.call(this, vm, hook);
            };
        }

        // è¦†ç›–Vueçš„å…¨å±€é”™è¯¯å¤„ç†
        const originalConfigErrorHandler = Vue.config.errorHandler;
        Vue.config.errorHandler = function (err, vm, info) {
            // å¿½ç•¥clientWidthç›¸å…³é”™è¯¯
            if (err.message && (
                err.message.includes('clientWidth') ||
                err.message.includes('clientHeight') ||
                err.message.includes('Cannot read properties of null')
            )) {
                return; // é™é»˜å¿½ç•¥
            }

            // å…¶ä»–é”™è¯¯ä½¿ç”¨åŸå§‹å¤„ç†å™¨æˆ–è¾“å‡ºåˆ°æ§åˆ¶å°
            if (originalConfigErrorHandler) {
                originalConfigErrorHandler.call(this, err, vm, info);
            } else {
                console.error('Vueé”™è¯¯:', err);
                console.error('ç»„ä»¶:', vm);
                console.error('ä¿¡æ¯:', info);
            }
        };

        // è¦†ç›–Vueçš„è­¦å‘Šç³»ç»Ÿ
        const originalWarn = console.warn;
        console.warn = function (...args) {
            const message = args.join(' ');
            // å¿½ç•¥ç‰¹å®šçš„Vueè­¦å‘Š
            if (message.includes('clientWidth') ||
                message.includes('Cannot read properties of null') ||
                message.includes('Error in mounted hook')) {
                return; // é™é»˜å¿½ç•¥
            }
            // å…¶ä»–è­¦å‘Šæ­£å¸¸è¾“å‡º
            return originalWarn.apply(console, args);
        };

        // åˆ›å»ºVueåº”ç”¨ï¼ˆä¸è‡ªåŠ¨æŒ‚è½½ï¼‰
        const app = new Vue({
            // ç§»é™¤elé€‰é¡¹ï¼Œæ”¹ä¸ºæ‰‹åŠ¨æŒ‚è½½
            data: {
                flashlightAngle: 10,          // çº¢å¤–çº¿å‘å°„å™¨è§’åº¦ (0-20Â°)
                sicThickness: 10.0,          // ç¢³åŒ–ç¡…å¤–å»¶å±‚åšåº¦ (5-15Î¼mï¼Œç²¾åº¦0.01)
                sicRefractiveIndex: 2.52,    // ç¢³åŒ–ç¡…æŠ˜å°„ç‡
                substrateRefractiveIndex: 3.05, // è¡¬åº•æŠ˜å°„ç‡
                numBeams: 5,                 // æ˜¾ç¤ºå…‰æŸæ•°é‡
                flashlightPosition: {x: 100, y: 40}, // çº¢å¤–çº¿å‘å°„å™¨ä½ç½®
                isDragging: false,           // æ˜¯å¦æ­£åœ¨æ‹–æ‹½
                dragOffset: {x: 0, y: 0},   // æ‹–æ‹½åç§»
                reflectionCoeff: 0,          // åå°„ç³»æ•°
                transmissionCoeff: 0,        // é€å°„ç³»æ•°
                interferenceOrder: 0,        // å¹²æ¶‰çº§æ¬¡
                canvas: null,                // Canvaså…ƒç´ 
                ctx: null,                   // Canvasä¸Šä¸‹æ–‡
                measurementResult: null,     // æµ‹é‡ç»“æœ
                resultText: ''               // ç»“æœæ–‡æœ¬
            },
            // ç§»é™¤updatedé’©å­ï¼Œé¿å…é‡å¤åˆå§‹åŒ–
            methods: {
                initializeCanvas() {
                    // é˜²æ­¢é‡å¤åˆå§‹åŒ–
                    if (this.canvas && this.ctx) {
                        console.log('Canvaså·²åˆå§‹åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–');
                        return;
                    }

                    try {
                        // å»¶è¿Ÿè·å–Canvaså…ƒç´ ï¼Œç¡®ä¿DOMå®Œå…¨å°±ç»ª
                        setTimeout(() => {
                            // è®¾ç½®Canvas
                            this.canvas = document.getElementById('simulationCanvas');

                            if (!this.canvas) {
                                console.error('æ‰¾ä¸åˆ°Canvaså…ƒç´  #simulationCanvas');
                                return;
                            }

                            this.ctx = this.canvas.getContext('2d');

                            if (!this.ctx) {
                                console.error('æ— æ³•è·å–Canvas 2Dä¸Šä¸‹æ–‡');
                                return;
                            }

                            console.log('Canvaså…ƒç´ è·å–æˆåŠŸ');

                            // è°ƒæ•´Canvaså¤§å°
                            this.resizeCanvas();

                            // æ·»åŠ çª—å£å¤§å°å˜åŒ–ç›‘å¬
                            window.addEventListener('resize', () => {
                                if (this.ctx) {
                                    this.resizeCanvas();
                                }
                            });

                            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
                            this.initEventListeners();

                            // åˆå§‹åŒ–å…‰å­¦å‚æ•°
                            this.calculateOpticalParameters();

                            // é»˜è®¤æ‰§è¡Œä¸€æ¬¡æµ‹é‡
                            this.performMeasurement();

                            // åˆå§‹ç»˜åˆ¶
                            if (this.ctx) {
                                this.draw();
                            }

                            console.log('Canvasåˆå§‹åŒ–æˆåŠŸ');
                        }, 200); // å¢åŠ å»¶è¿Ÿæ—¶é—´

                    } catch (error) {
                        console.error('Canvasåˆå§‹åŒ–è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
                    }
                },

                resizeCanvas() {
                    try {
                        if (!this.canvas) return;

                        const container = this.canvas.parentElement;
                        if (!container) {
                            console.warn('Canvaså®¹å™¨ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯¸');
                            this.canvas.width = 800;
                            this.canvas.height = 400;
                            if (this.ctx) this.draw();
                            return;
                        }

                        // è·å–å®¹å™¨å°ºå¯¸ï¼Œæ·»åŠ å®‰å…¨æ£€æŸ¥
                        let containerWidth = 800;
                        let containerHeight = 400;

                        try {
                            if (container && typeof container.clientWidth === 'number' && container.clientWidth > 0) {
                                containerWidth = container.clientWidth;
                            } else if (container && typeof container.offsetWidth === 'number' && container.offsetWidth > 0) {
                                containerWidth = container.offsetWidth;
                            }

                            if (container && typeof container.clientHeight === 'number' && container.clientHeight > 0) {
                                containerHeight = container.clientHeight;
                            } else if (container && typeof container.offsetHeight === 'number' && container.offsetHeight > 0) {
                                containerHeight = container.offsetHeight;
                            }
                        } catch (e) {
                            console.warn('æ— æ³•è·å–å®¹å™¨å°ºå¯¸ï¼Œä½¿ç”¨é»˜è®¤å€¼:', e);
                        }

                        // è®¾ç½®Canvaså°ºå¯¸
                        this.canvas.width = containerWidth;
                        this.canvas.height = containerHeight;

                        // é‡æ–°ç»˜åˆ¶
                        if (this.ctx) this.draw();
                    } catch (error) {
                        console.error('Error resizing canvas:', error);
                        // è®¾ç½®é»˜è®¤å°ºå¯¸ä»¥é˜²æ­¢å®Œå…¨å¤±è´¥
                        if (this.canvas) {
                            this.canvas.width = 800;
                            this.canvas.height = 400;
                            if (this.ctx) this.draw();
                        }
                    }
                },

                // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
                initEventListeners() {
                    // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆæ‹–æ‹½æ‰‹ç”µç­’ï¼‰
                    document.addEventListener('mousemove', (e) => {
                        if (this.isDragging) {
                            try {
                                const simulationContainer = document.querySelector('.simulation-container');
                                if (simulationContainer && this.canvas) {
                                    const rect = simulationContainer.getBoundingClientRect();
                                    // æ£€æŸ¥rectæ˜¯å¦æœ‰æ•ˆ
                                    if (rect && rect.left !== undefined && rect.top !== undefined) {
                                        this.flashlightPosition.x = e.clientX - rect.left - this.dragOffset.x;
                                        // é™åˆ¶æ‰‹ç”µç­’åªèƒ½åœ¨ç©ºæ°”å±‚ç§»åŠ¨
                                        this.flashlightPosition.x = Math.max(50, Math.min(this.canvas.width - 50, this.flashlightPosition.x));
                                        this.flashlightPosition.y = 30; // å›ºå®šYä½ç½®åœ¨ç©ºæ°”å±‚å†…
                                        if (this.ctx) this.draw();
                                    }
                                }
                            } catch (error) {
                                console.error('Error in mousemove handler:', error);
                            }
                        }
                    });

                    // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
                    document.addEventListener('mouseup', () => {
                        this.isDragging = false;
                    });
                },

                // å¼€å§‹æ‹–æ‹½
                startDragging(e) {
                    e.preventDefault();
                    try {
                        this.isDragging = true;
                        if (e && e.currentTarget) {
                            const rect = e.currentTarget.getBoundingClientRect();
                            this.dragOffset.x = e.clientX - rect.left;
                            this.dragOffset.y = e.clientY - rect.top;
                        } else {
                            // å¦‚æœæ— æ³•è·å–å…ƒç´ ï¼Œä½¿ç”¨é»˜è®¤åç§»
                            this.dragOffset.x = 0;
                            this.dragOffset.y = 0;
                        }
                    } catch (error) {
                        console.error('Error in startDragging:', error);
                        this.isDragging = false;
                        this.dragOffset.x = 0;
                        this.dragOffset.y = 0;
                    }
                },

                // æ›´æ–°æ¨¡æ‹Ÿ
                updateSimulation() {
                    console.log('æ›´æ–°æ¨¡æ‹Ÿï¼Œå½“å‰å‚æ•°:', {
                        flashlightAngle: this.flashlightAngle,
                        sicThickness: this.sicThickness,
                        sicRefractiveIndex: this.sicRefractiveIndex,
                        substrateRefractiveIndex: this.substrateRefractiveIndex,
                        numBeams: this.numBeams
                    });

                    // é‡æ–°è®¡ç®—å…‰å­¦å‚æ•°
                    this.calculateOpticalParameters();

                    // é‡æ–°ç»˜åˆ¶
                    if (this.ctx) {
                        this.draw();
                    }

                    // æ‰§è¡Œæµ‹é‡
                    this.performMeasurement();
                },
                // æ‰§è¡Œæµ‹é‡ï¼Œä¸åç«¯äº¤äº’
                performMeasurement() {
                    const params = {
                        incidentAngle: parseFloat(this.flashlightAngle),
                        thickness: parseFloat(this.sicThickness),
                        nAir: 1.0,
                        nSic: parseFloat(this.sicRefractiveIndex),
                        nSubstrate: parseFloat(this.substrateRefractiveIndex),
                        numBeams: parseInt(this.numBeams)
                    };

                    fetch('/api/measure', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(params)
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('åç«¯å“åº”é”™è¯¯');
                            }
                            return response.json();
                        })
                        .then(result => {
                            // æ›´æ–°æµ‹é‡ç»“æœ
                            this.measurementResult = result;
                            // æ›´æ–°UIæ˜¾ç¤º
                            this.updateResultDisplay();
                            // æ›´æ–°ç»˜åˆ¶
                            if (this.ctx) this.draw();
                        })
                        .catch(error => {
                            console.error('æµ‹é‡å¤±è´¥:', error);
                            this.measurementResult = null;
                            this.resultText = 'æµ‹é‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æœåŠ¡æˆ–å‚æ•°è®¾ç½®';
                        });
                },
                // æ›´æ–°ç»“æœæ˜¾ç¤º
                updateResultDisplay() {
                    if (this.measurementResult && typeof this.measurementResult === 'object') {
                        const result = this.measurementResult;
                        try {
                            // å®‰å…¨æ£€æŸ¥æ‰€æœ‰æ•°å€¼å­—æ®µ
                            const incidentAngle = result.incidentAngle || 0;
                            const nSic = result.nSic || 0;
                            const nSubstrate = result.nSubstrate || 0;
                            const calculatedThickness = result.calculatedThickness || 0;
                            const setThickness = result.setThickness || 0;
                            const relativeError = result.relativeError || 0;
                            const r1 = result.r1 || 0;
                            const r2 = result.r2 || 0;
                            const numBeams = result.numBeams || 0;

                            // ç¡®ä¿æ‰€æœ‰å€¼éƒ½æ˜¯æ•°å­—
                            const safeIncidentAngle = typeof incidentAngle === 'number' ? incidentAngle : parseFloat(incidentAngle) || 0;
                            const safeNSic = typeof nSic === 'number' ? nSic : parseFloat(nSic) || 0;
                            const safeNSubstrate = typeof nSubstrate === 'number' ? nSubstrate : parseFloat(nSubstrate) || 0;
                            const safeCalculatedThickness = typeof calculatedThickness === 'number' ? calculatedThickness : parseFloat(calculatedThickness) || 0;
                            const safeSetThickness = typeof setThickness === 'number' ? setThickness : parseFloat(setThickness) || 0;
                            const safeRelativeError = typeof relativeError === 'number' ? relativeError : parseFloat(relativeError) || 0;
                            const safeR1 = typeof r1 === 'number' ? r1 : parseFloat(r1) || 0;
                            const safeR2 = typeof r2 === 'number' ? r2 : parseFloat(r2) || 0;
                            const safeNumBeams = typeof numBeams === 'number' ? numBeams : parseInt(numBeams) || 0;

                            this.resultText = `ã€åšåº¦æµ‹é‡æŠ¥å‘Šã€‘\nğŸ”§ æµ‹é‡å‚æ•°ï¼š\n  å…¥å°„è§’: ${safeIncidentAngle.toFixed(1)}Â°\n  SiCæŠ˜å°„ç‡: ${safeNSic.toFixed(3)}\n  è¡¬åº•æŠ˜å°„ç‡: ${safeNSubstrate.toFixed(3)}\nğŸ“ æµ‹é‡ç»“æœï¼š\n  è®¡ç®—åšåº¦: ${safeCalculatedThickness.toFixed(3)} Î¼m\n  è®¾å®šåšåº¦: ${safeSetThickness.toFixed(3)} Î¼m\n  ç›¸å¯¹è¯¯å·®: ${safeRelativeError.toFixed(2)}%\nğŸ” å¹²æ¶‰æ¡ä»¶è¯„ä¼°ï¼š\n  ç•Œé¢åå°„ç‡ R1: ${(safeR1 * 100).toFixed(1)}%\n  è¡¬åº•åå°„ç‡ R2: ${(safeR2 * 100).toFixed(1)}%\n  æ˜¯å¦æ»¡è¶³å¼ºå¹²æ¶‰: ${result.strongInterference ? 'æ˜¯' : 'å¦'}\n  åˆ†æå…‰æŸæ•°: ${safeNumBeams}`;
                        } catch (error) {
                            console.error('æ›´æ–°ç»“æœæ˜¾ç¤ºæ—¶å‡ºé”™:', error);
                            this.resultText = 'ç»“æœæ˜¾ç¤ºæ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥åç«¯è¿”å›æ•°æ®';
                        }
                    } else {
                        this.resultText = 'æš‚æ— æµ‹é‡ç»“æœ';
                    }
                },

                // é‡ç½®æ¨¡æ‹Ÿ
                resetSimulation() {
                    this.flashlightAngle = 10;
                    this.sicThickness = 7.32;
                    this.sicRefractiveIndex = 2.52;
                    this.substrateRefractiveIndex = 3.05;
                    this.numBeams = 5;
                    this.flashlightPosition = {x: 100, y: 40};
                    this.updateSimulation();
                    if (this.ctx) this.draw();
                },

                // è®¡ç®—å…‰å­¦å‚æ•°
                calculateOpticalParameters() {
                    const n1 = 1.0; // ç©ºæ°”
                    const n2 = this.sicRefractiveIndex;
                    const n3 = this.substrateRefractiveIndex;

                    // è®¡ç®—åå°„ç³»æ•°ï¼ˆç®€å•æ¨¡å‹ï¼‰
                    const r1 = (n1 - n2) / (n1 + n2);
                    const r2 = (n2 - n3) / (n2 + n3);
                    this.reflectionCoeff = Math.abs(r1);

                    // è®¡ç®—é€å°„ç³»æ•°
                    this.transmissionCoeff = Math.sqrt(1 - this.reflectionCoeff * this.reflectionCoeff);

                    // è®¡ç®—å¹²æ¶‰çº§æ¬¡ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
                    const theta = this.flashlightAngle * Math.PI / 180;
                    const wavelength = 1.55; // çº¢å¤–æ³¢é•¿ (Î¼m)
                    this.interferenceOrder = Math.floor(2 * n2 * this.sicThickness * Math.cos(theta) / wavelength);
                },

                // è®¡ç®—å…‰çº¿è·¯å¾„ï¼ˆå‚è€ƒSimulation.pyçš„draw_beam_propagationæ–¹æ³•ï¼‰
                calculateLightPaths() {
                    const paths = [];
                    const startX = this.flashlightPosition.x;
                    const startY = this.flashlightPosition.y;

                    // ä½¿ç”¨ä¸drawMaterialLayersç›¸åŒçš„è¾¹ç•Œè®¡ç®—é€»è¾‘
                    const layerAirHeight = 80; // ç©ºæ°”å±‚é«˜åº¦
                    const airSicBoundary = layerAirHeight;
                    const sicSubstrateBoundary = airSicBoundary + this.sicThickness * 8;

                    // å…¥å°„è§’ï¼ˆå¼§åº¦ï¼‰
                    const incidentAngle = this.flashlightAngle * Math.PI / 180;

                    // è®¡ç®—æŠ˜å°„è§’ï¼ˆæ–¯æ¶…å°”å®šå¾‹ï¼‰
                    const n1 = 1.0; // ç©ºæ°”
                    const n2 = this.sicRefractiveIndex;
                    const n3 = this.substrateRefractiveIndex;

                    // è®¡ç®—ç¬¬ä¸€ä¸ªç•Œé¢çš„æŠ˜å°„è§’
                    let refractionAngle1 = 0;
                    let totalInternalReflection1 = false;
                    const sinTheta1 = n1 * Math.sin(incidentAngle) / n2;

                    if (Math.abs(sinTheta1) > 1) {
                        totalInternalReflection1 = true;
                    } else {
                        refractionAngle1 = Math.asin(sinTheta1);
                    }

                    // è®¡ç®—ç¬¬äºŒä¸ªç•Œé¢çš„æŠ˜å°„è§’
                    let refractionAngle2 = 0;
                    let totalInternalReflection2 = false;

                    if (!totalInternalReflection1) {
                        const sinTheta2 = n2 * Math.sin(refractionAngle1) / n3;
                        if (Math.abs(sinTheta2) > 1) {
                            totalInternalReflection2 = true;
                        } else {
                            refractionAngle2 = Math.asin(sinTheta2);
                        }
                    }

                    // è®¡ç®—åˆ°ç©ºæ°”-ç¢³åŒ–ç¡…ç•Œé¢çš„äº¤ç‚¹
                    const dx1 = (airSicBoundary - startY) / Math.tan(incidentAngle);
                    const intersection1X = startX + dx1;
                    const intersection1Y = airSicBoundary;

                    // ç”Ÿæˆå¤šå…‰æŸå¹²æ¶‰è·¯å¾„ï¼ˆå®Œå…¨å‚è€ƒPythonå®ç°ï¼‰
                    const colors = this.generateBeamColors(this.numBeams);
                    let max_x = startX;

                    for (let i = 0; i < this.numBeams; i++) {
                        const path = [];

                        // ä»å‘å°„å™¨ä½ç½®å¼€å§‹
                        path.push({x: startX, y: startY});

                        // å…¥å°„åˆ°ç©ºæ°”-SiCç•Œé¢
                        path.push({x: intersection1X, y: intersection1Y});

                        if (i === 0) {
                            // ç¬¬ä¸€æŸï¼šè¡¨é¢ç›´æ¥åå°„
                            const reflectEndX = intersection1X - 150 * Math.cos(incidentAngle);
                            const reflectEndY = intersection1Y - 150 * Math.sin(incidentAngle);
                            path.push({x: reflectEndX, y: reflectEndY});
                        } else {
                            // å…¶ä»–å…‰æŸï¼šå¤šæ¬¡åå°„åœ¨SiCå±‚ä¸­ï¼ˆå‚è€ƒPythoné€»è¾‘ï¼‰
                            let currentX = intersection1X;
                            let currentY = intersection1Y;

                            // è®¡ç®—å•æ¬¡é€šè¿‡SiCå±‚çš„æ°´å¹³åç§»
                            const dx = this.sicThickness * 8 * Math.tan(refractionAngle1);

                            // æ„å»ºåå°„è·¯å¾„ç‚¹
                            const points_x = [currentX];
                            const points_y = [currentY];

                            for (let bounce = 0; bounce < i; bounce++) {
                                // å‘ä¸‹èµ°åˆ°åº•
                                let x_next = points_x[points_x.length - 1] + dx;
                                let y_next = sicSubstrateBoundary;
                                points_x.push(x_next);
                                points_y.push(y_next);

                                // å‘ä¸Šè¿”å›è¡¨é¢
                                x_next += dx;
                                y_next = airSicBoundary;
                                points_x.push(x_next);
                                points_y.push(y_next);
                            }

                            // æœ€åä¸€æ¬¡å‘ä¸Šå‡ºå°„
                            let x_final = points_x[points_x.length - 1] - 150 * Math.cos(incidentAngle);
                            let y_final = points_y[points_y.length - 1] - 150 * Math.sin(incidentAngle);
                            points_x.push(x_final);
                            points_y.push(y_final);

                            // è½¬æ¢ä¸ºpathæ ¼å¼
                            for (let j = 0; j < points_x.length; j++) {
                                path.push({x: points_x[j], y: points_y[j]});
                            }

                            // æ›´æ–°æœ€å¤§xå€¼
                            const current_max = Math.max(...points_x);
                            if (current_max > max_x) {
                                max_x = current_max;
                            }
                        }

                        paths.push({
                            points: path,
                            color: colors[i],
                            index: i
                        });
                    }

                    return {paths: paths, max_x: max_x};
                },

                // ç”Ÿæˆå…‰æŸé¢œè‰²ï¼ˆå‚è€ƒPythonçš„viridisé¢œè‰²æ˜ å°„ï¼‰
                generateBeamColors(numBeams) {
                    const colors = [];
                    for (let i = 0; i < numBeams; i++) {
                        const t = i / Math.max(1, numBeams - 1);
                        // ç®€åŒ–çš„viridisé¢œè‰²æ˜ å°„
                        let r, g, b;
                        if (t < 0.25) {
                            r = 68 + (59 - 68) * (t / 0.25);
                            g = 1 + (82 - 1) * (t / 0.25);
                            b = 84 + (139 - 84) * (t / 0.25);
                        } else if (t < 0.5) {
                            r = 59 + (33 - 59) * ((t - 0.25) / 0.25);
                            g = 82 + (144 - 82) * ((t - 0.25) / 0.25);
                            b = 139 + (140 - 139) * ((t - 0.25) / 0.25);
                        } else if (t < 0.75) {
                            r = 33 + (62 - 33) * ((t - 0.5) / 0.25);
                            g = 144 + (193 - 144) * ((t - 0.5) / 0.25);
                            b = 140 + (90 - 140) * ((t - 0.5) / 0.25);
                        } else {
                            r = 62 + (253 - 62) * ((t - 0.75) / 0.25);
                            g = 193 + (231 - 193) * ((t - 0.75) / 0.25);
                            b = 90 + (37 - 90) * ((t - 0.75) / 0.25);
                        }
                        colors.push({r: Math.floor(r), g: Math.floor(g), b: Math.floor(b)});
                    }
                    return colors;
                },

                // ç»˜åˆ¶å‡½æ•°
                draw() {
                    if (!this.ctx) return;

                    // æ¸…ç©ºCanvas
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    // ç»˜åˆ¶èƒŒæ™¯
                    this.ctx.fillStyle = '#f0f0f0';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // ç»˜åˆ¶ææ–™å±‚
                    this.drawMaterialLayers();

                    // è®¡ç®—å¹¶ç»˜åˆ¶å…‰çº¿è·¯å¾„
                    const result = this.calculateLightPaths();
                    this.drawLightPaths(result.paths);

                    // ç»˜åˆ¶æ‰‹ç”µç­’å…‰çº¿é¢„è§ˆ
                    this.drawFlashlightBeam();
                },

                // ç»˜åˆ¶ææ–™å±‚ï¼ˆå‚è€ƒPythonå®ç°çš„çœŸå®å®éªŒåœºæ™¯ï¼‰
                drawMaterialLayers() {
                    // ä½¿ç”¨ä¸calculateLightPathsç›¸åŒçš„è¾¹ç•Œè®¡ç®—é€»è¾‘
                    const layerAirHeight = 80; // ç©ºæ°”å±‚é«˜åº¦
                    const airSicBoundary = layerAirHeight;
                    const sicSubstrateBoundary = airSicBoundary + this.sicThickness * 8;

                    // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼ï¼ˆå®éªŒå®¤é£æ ¼ï¼‰
                    this.ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                    this.ctx.lineWidth = 0.5;
                    const gridSize = 20;

                    for (let x = 0; x < this.canvas.width; x += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.height);
                        this.ctx.stroke();
                    }

                    for (let y = 0; y < this.canvas.height; y += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.canvas.width, y);
                        this.ctx.stroke();
                    }

                    // ç»˜åˆ¶åæ ‡è½´
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 2;

                    // Xè½´
                    this.ctx.beginPath();
                    this.ctx.moveTo(50, this.canvas.height - 50);
                    this.ctx.lineTo(this.canvas.width - 20, this.canvas.height - 50);
                    this.ctx.stroke();

                    // Yè½´
                    this.ctx.beginPath();
                    this.ctx.moveTo(50, 20);
                    this.ctx.lineTo(50, this.canvas.height - 50);
                    this.ctx.stroke();

                    // ç»˜åˆ¶åæ ‡è½´æ ‡ç­¾
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText('ä½ç½® (Î¼m)', this.canvas.width - 100, this.canvas.height - 30);
                    this.ctx.save();
                    this.ctx.translate(20, this.canvas.height / 2);
                    this.ctx.rotate(-Math.PI / 2);
                    this.ctx.fillText('æ·±åº¦ (Î¼m)', 0, 0);
                    this.ctx.restore();

                    // ç»˜åˆ¶ç©ºæ°”å±‚ - æ·¡è“è‰²æ¸å˜
                    const airGradient = this.ctx.createLinearGradient(0, 0, 0, airSicBoundary);
                    airGradient.addColorStop(0, 'rgba(135,206,250,0.3)');
                    airGradient.addColorStop(1, 'rgba(135,206,250,0.1)');
                    this.ctx.fillStyle = airGradient;
                    this.ctx.fillRect(0, 0, this.canvas.width, airSicBoundary);

                    // ç»˜åˆ¶ç¢³åŒ–ç¡…å±‚ - è“è‰²æ¸å˜ï¼Œå¸¦çº¹ç†æ•ˆæœ
                    const sicGradient = this.ctx.createLinearGradient(0, airSicBoundary, 0, sicSubstrateBoundary);
                    sicGradient.addColorStop(0, 'rgba(70,130,180,0.5)');
                    sicGradient.addColorStop(0.5, 'rgba(70,130,180,0.3)');
                    sicGradient.addColorStop(1, 'rgba(70,130,180,0.2)');
                    this.ctx.fillStyle = sicGradient;
                    this.ctx.fillRect(0, airSicBoundary, this.canvas.width, sicSubstrateBoundary - airSicBoundary);

                    // æ·»åŠ SiCå±‚çº¹ç†æ•ˆæœ
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    this.ctx.lineWidth = 0.5;
                    for (let x = 0; x < this.canvas.width; x += 20) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, airSicBoundary);
                        this.ctx.lineTo(x, sicSubstrateBoundary);
                        this.ctx.stroke();
                    }

                    // ç»˜åˆ¶è¡¬åº•å±‚ - ç°è‰²æ¸å˜
                    const substrateGradient = this.ctx.createLinearGradient(0, sicSubstrateBoundary, 0, this.canvas.height);
                    substrateGradient.addColorStop(0, 'rgba(105,105,105,0.5)');
                    substrateGradient.addColorStop(0.5, 'rgba(105,105,105,0.3)');
                    substrateGradient.addColorStop(1, 'rgba(105,105,105,0.2)');
                    this.ctx.fillStyle = substrateGradient;
                    this.ctx.fillRect(0, sicSubstrateBoundary, this.canvas.width, this.canvas.height - sicSubstrateBoundary);

                    // ç»˜åˆ¶ç•Œé¢çº¿ - æ›´æ˜æ˜¾çš„åˆ†ç•Œçº¿
                    this.ctx.strokeStyle = '#4682b4';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, airSicBoundary);
                    this.ctx.lineTo(this.canvas.width, airSicBoundary);
                    this.ctx.stroke();

                    this.ctx.strokeStyle = '#696969';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, sicSubstrateBoundary);
                    this.ctx.lineTo(this.canvas.width, sicSubstrateBoundary);
                    this.ctx.stroke();

                    // æ·»åŠ å±‚æ ‡ç­¾ - æ›´ä¸“ä¸šçš„æ ·å¼
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    this.ctx.shadowBlur = 3;
                    this.ctx.shadowOffsetX = 1;
                    this.ctx.shadowOffsetY = 1;

                    this.ctx.fillText('ç©ºæ°”å±‚ (n=1.0)', 15, 25);
                    this.ctx.fillText(`SiCå¤–å»¶å±‚ (${this.sicThickness.toFixed(2)}Î¼m, n=${this.sicRefractiveIndex.toFixed(2)})`, 15, airSicBoundary + 25);
                    this.ctx.fillText('è¡¬åº•å±‚ (n=' + this.substrateRefractiveIndex.toFixed(2) + ')', 15, sicSubstrateBoundary + 25);

                    // é‡ç½®é˜´å½±
                    this.ctx.shadowColor = 'transparent';
                    this.ctx.shadowBlur = 0;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 0;

                    // æ·»åŠ åˆ»åº¦æ ‡è®°
                    this.drawScaleMarks();
                },

                // ç»˜åˆ¶åˆ»åº¦æ ‡è®°
                drawScaleMarks() {
                    this.ctx.strokeStyle = '#666';
                    this.ctx.fillStyle = '#666';
                    this.ctx.font = '10px Arial';
                    this.ctx.lineWidth = 1;

                    // Yè½´åˆ»åº¦
                    const yMarks = [0, 80, 80 + this.sicThickness * 8, this.canvas.height - 50];
                    const yLabels = ['0', '80', `${(80 + this.sicThickness * 8).toFixed(0)}`, ''];

                    yMarks.forEach((y, index) => {
                        if (index < yLabels.length && yLabels[index]) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(45, y);
                            this.ctx.lineTo(55, y);
                            this.ctx.stroke();
                            this.ctx.fillText(yLabels[index], 25, y + 3);
                        }
                    });

                    // Xè½´åˆ»åº¦
                    for (let x = 100; x < this.canvas.width; x += 100) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, this.canvas.height - 55);
                        this.ctx.lineTo(x, this.canvas.height - 45);
                        this.ctx.stroke();
                        this.ctx.fillText(`${(x - 50).toFixed(0)}`, x - 10, this.canvas.height - 35);
                    }
                },

                // ç»˜åˆ¶å…‰çº¿è·¯å¾„ï¼ˆå‚è€ƒPythonå®ç°ï¼‰
                drawLightPaths(paths) {
                    paths.forEach((pathData) => {
                        const {points, color, index} = pathData;

                        // ä½¿ç”¨viridisé¢œè‰²æ˜ å°„
                        const intensity = 0.8 - (index * 0.05);
                        this.ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${intensity})`;
                        this.ctx.lineWidth = 2.5 - (index * 0.15); // ä¸»å…‰æŸæ›´ç²—
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';

                        // æ·»åŠ å‘å…‰æ•ˆæœ
                        this.ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, 0.6)`;
                        this.ctx.shadowBlur = 8;

                        this.ctx.beginPath();

                        // ç»˜åˆ¶è·¯å¾„
                        points.forEach((point, i) => {
                            if (i === 0) {
                                this.ctx.moveTo(point.x, point.y);
                            } else {
                                this.ctx.lineTo(point.x, point.y);
                            }
                        });

                        this.ctx.stroke();

                        // ç»˜åˆ¶ç®­å¤´æŒ‡ç¤ºæ–¹å‘
                        if (points.length > 1) {
                            this.drawArrow(points[points.length - 2], points[points.length - 1]);
                        }

                        // é‡ç½®é˜´å½±å’Œé€æ˜åº¦
                        this.ctx.shadowColor = 'transparent';
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = 1;
                    });
                },

                // ç»˜åˆ¶ç®­å¤´
                drawArrow(from, to) {
                    const headLength = 10;
                    const angle = Math.atan2(to.y - from.y, to.x - from.x);

                    this.ctx.beginPath();
                    this.ctx.moveTo(to.x, to.y);
                    this.ctx.lineTo(
                        to.x - headLength * Math.cos(angle - Math.PI / 6),
                        to.y - headLength * Math.sin(angle - Math.PI / 6)
                    );
                    this.ctx.moveTo(to.x, to.y);
                    this.ctx.lineTo(
                        to.x - headLength * Math.cos(angle + Math.PI / 6),
                        to.y - headLength * Math.sin(angle + Math.PI / 6)
                    );
                    this.ctx.stroke();
                },

                // ç»˜åˆ¶çº¢å¤–çº¿å‘å°„å™¨å…‰æŸé¢„è§ˆ
                drawFlashlightBeam() {
                    const angle = this.flashlightAngle * Math.PI / 180;
                    const startX = this.flashlightPosition.x;
                    const startY = this.flashlightPosition.y;

                    // ç»˜åˆ¶çº¢å¤–çº¿å…‰æŸåœ†é”¥ - çº¢è‰²æ¸å˜æ•ˆæœ
                    const beamLength = 120;
                    const beamAngle = Math.PI / 10; // ç¨å¾®å¢å¤§å‘æ•£è§’

                    // åˆ›å»ºçº¢å¤–çº¿æ¸å˜
                    const gradient = this.ctx.createLinearGradient(
                        startX, startY,
                        startX + beamLength * Math.cos(angle),
                        startY + beamLength * Math.sin(angle)
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.6)');
                    gradient.addColorStop(0.5, 'rgba(255, 50, 50, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 100, 100, 0.1)');

                    this.ctx.fillStyle = gradient;
                    this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
                    this.ctx.lineWidth = 1;

                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);

                    const endX1 = startX + beamLength * Math.cos(angle + beamAngle);
                    const endY1 = startY + beamLength * Math.sin(angle + beamAngle);
                    const endX2 = startX + beamLength * Math.cos(angle - beamAngle);
                    const endY2 = startY + beamLength * Math.sin(angle - beamAngle);

                    this.ctx.lineTo(endX1, endY1);
                    this.ctx.lineTo(endX2, endY2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();

                    // æ·»åŠ è„‰å†²ä¸­å¿ƒçº¿æ•ˆæœ
                    this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(
                        startX + beamLength * 0.8 * Math.cos(angle),
                        startY + beamLength * 0.8 * Math.sin(angle)
                    );
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }
        });

        // ä½¿ç”¨æ›´å®‰å…¨çš„DOMå°±ç»ªæ£€æŸ¥
        function initializeApp() {
            try {
                // æ£€æŸ¥ç›®æ ‡å…ƒç´ æ˜¯å¦å­˜åœ¨
                const targetElement = document.getElementById('app');
                if (!targetElement) {
                    console.error('æ‰¾ä¸åˆ°æŒ‚è½½ç›®æ ‡å…ƒç´  #app');
                    return;
                }

                // æ£€æŸ¥Canvaså…ƒç´ æ˜¯å¦å­˜åœ¨
                const canvasElement = document.getElementById('simulationCanvas');
                if (!canvasElement) {
                    console.error('æ‰¾ä¸åˆ°Canvaså…ƒç´  #simulationCanvas');
                    return;
                }

                console.log('DOMå…ƒç´ æ£€æŸ¥é€šè¿‡ï¼Œå¼€å§‹æŒ‚è½½Vueåº”ç”¨');

                // å…ˆæŒ‚è½½Vueåº”ç”¨
                app.$mount('#app');
                console.log('Vueåº”ç”¨æŒ‚è½½æˆåŠŸ');

                // æŒ‚è½½ååˆå§‹åŒ–Canvas
                setTimeout(() => {
                    if (!app.canvas) {
                        app.initializeCanvas();
                    }

                    // æµ‹è¯•åº”ç”¨åŠŸèƒ½
                    setTimeout(() => {
                        console.log('=== åº”ç”¨åŠŸèƒ½æµ‹è¯• ===');
                        console.log('Vueåº”ç”¨çŠ¶æ€:', app.$el ? 'å·²æŒ‚è½½' : 'æœªæŒ‚è½½');
                        console.log('CanvasçŠ¶æ€:', app.canvas ? 'å·²åˆå§‹åŒ–' : 'æœªåˆå§‹åŒ–');
                        console.log('æ•°æ®çŠ¶æ€:', {
                            flashlightAngle: app.flashlightAngle,
                            sicThickness: app.sicThickness,
                            numBeams: app.numBeams
                        });

                        // æµ‹è¯•ç»˜åˆ¶åŠŸèƒ½
                        if (app.canvas && app.ctx) {
                            console.log('Canvaså°ºå¯¸:', app.canvas.width + 'x' + app.canvas.height);
                            console.log('ç»˜åˆ¶åŠŸèƒ½: å¯ç”¨');

                            // å°è¯•æ‰§è¡Œä¸€æ¬¡ç»˜åˆ¶
                            try {
                                app.draw();
                                console.log('ç»˜åˆ¶æµ‹è¯•: æˆåŠŸ');
                            } catch (e) {
                                console.log('ç»˜åˆ¶æµ‹è¯•: å¤±è´¥ -', e.message);
                            }
                        } else {
                            console.log('CanvasåŠŸèƒ½: ä¸å¯ç”¨');
                        }

                        console.log('=== æµ‹è¯•å®Œæˆ ===');
                    }, 1000);

                }, 300);

            } catch (error) {
                console.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // å¤šé‡æ£€æŸ¥ç¡®ä¿DOMå®Œå…¨å°±ç»ª
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            // DOMå·²ç»å°±ç»ªï¼Œä½†å¯èƒ½Canvasè¿˜æœªå®Œå…¨å‡†å¤‡å¥½
            setTimeout(initializeApp, 100);
        }
    });
</script>
</body>
</html>